<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>Mysql技术内幕-InnoDB存储引擎 - Miguel's Wiki</title>
    <meta name="keywords" content=""/>
    <meta name="description" content="侯铭健的个人wiki"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/wiki/">Home</a>&nbsp;&#187;&nbsp;<a href="/wiki/#Book">Book</a>&nbsp;&#187;&nbsp;Mysql技术内幕-InnoDB存储引擎
    <span class="updated">Page Updated&nbsp;
      2019-07-03 10:25:37
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">Mysql技术内幕-InnoDB存储引擎</div>

  <h2 id="mysql">mysql引擎</h2>
<p>1.InnoDB - 支持事务，行锁，非锁定读</p>
<p>2.MyISAM - 不支持事务</p>
<h2 id="acid">ACID</h2>
<p>摘自维基百科</p>
<blockquote>
<p>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、可约简。</p>
<p>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</p>
<p>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
<p>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
</blockquote>
<h2 id="innodb">Innodb存储引擎</h2>
<h3 id="_1">缓冲池</h3>
<p>1.数据库中，磁盘上的数据会按页读取，并且页会缓存在缓冲池中。<br />
2.页会按照LRU进行淘汰。LRU插入位置为mid-point，防止热点页被快速淘汰，不是朴素的LRU算法。<br />
3.数据更新时，会先更新缓冲池中的页，然后再刷新回磁盘中。<br />
4.为解决缓冲池与磁盘中数据的一致，InnoDB会在事务提交时，先写入重做日志，如果数据库发生意外宕机，可以通过重做日志将磁盘数据恢复到宕机前的状态。<br />
5.缓冲池中页数据刷入磁盘的时间与checkpoint有关。</p>
<h3 id="_2">重做日志缓冲</h3>
<p>1.重做日志会先写入到重做日志缓冲区，缓冲区数据每秒刷入磁盘。(默认8m/s每秒)</p>
<h3 id="_3">插入缓冲</h3>
<ol>
<li>自增的ID主键很重要，因为按顺序插入的主键不需要随机读取磁盘数据。</li>
</ol>
<p>2.非聚集索引插入时，若满足以下两个条件（1.非唯一，2.辅助索引），则会先判断非聚集索引页是否在缓冲池中，若存在，则直接插入，若不存在，则先插入缓冲，然后以一定的频率刷回磁盘。</p>
<p>所以表中，唯一索引会影响数据插入的速率。</p>
<h3 id="double-write">Double-write</h3>
<p>缓冲池中脏页在写入磁盘时，可能会受到宕机的影响导致脏页数据未完全写入磁盘，导致数据丢失。<br />
为了解决这个问题，Innodb引入了double-write机制。</p>
<p>double-write的流程是，脏页数据会先写入double-write缓冲区中(doublewrite-buffer)，然后doublewrite-buffer中数据会写入共享空间磁盘，写入成功后，才会真正写入到数据存储的磁盘中。</p>
<p>如果在写入数据存储磁盘时发生意外宕机，磁盘中数据只写入了一部分，mysql会从共享空间磁盘中直接将该页数据复制到数据存储磁盘。</p>
<p>关于doublewrite的性能影响其实并不大，原因是第一是脏页中一般会有很多数据同时刷新到磁盘，Innodb会将这些操作进行合并操作，减少fasync的操作次数。第二是写入共享空间时是顺序写入的。</p>
<h2 id="_4">表</h2>
<h3 id="innodb_1">InnoDB逻辑存储结构</h3>
<p>摘自书中截图</p>
<p><img alt="" src="https://ws1.sinaimg.cn/large/005H7Wvygy1g4vsbs0t58j31640sck32.jpg" /></p>
<h2 id="_5">关于索引</h2>
<p>1、索引要建立在区分度较大的字段上，如果是那种只有0 1 2的就不要建立索引了，可以考虑建联合索引</p>
<p>2、联合索引要把区分度大的放前面，如联合索引AB，如果只查B的话是不会走索引的。只有查 A或者AB会走索</p>
<p>3.B+Tree的讲解</p>
<p><a href="https://blog.csdn.net/qq_26222859/article/details/80631121">漫画解B+Tree</a></p>
<h2 id="_6">锁</h2>
<p>1、讲解的B+tree例子不错，深入浅出，强烈推荐</p>
<p>2、关于死锁的问题，除了AB-BA这种互相等待的死锁外，还有另外一种死锁</p>
<ul>
<li>当前事务持有了待插入记录下一个记录的X锁，但是在等待队列中存在一个S锁的请求</li>
</ul>
<p>3、锁升级，粒度从行到页再到表，从细到粗</p>
<ul>
<li>升级锁是因为锁的开销比较大，系统需要使用较多内存维护锁。但是升级锁同时并发性能会降低。</li>
<li>InnoDB不存在锁升级的问题，因为其是根据事务访问的每个页对锁进行管理的。即页锁。</li>
</ul>
<p>4、如果一个列里面重复数据特别多，那就不适合加索引。</p>
<h3 id="_7">一致性非锁定读</h3>
<p>InnoDB通过多版本控制读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE和UPDATE操作，这时候读取操作不会等待行上锁释放，而是去读快照版本。</p>
<h2 id="_8">疑问</h2>
<p>缓冲池中</p>
<p>1.数据页和索引页是以什么形式存储在里面。</p>
<p>2.事务处理的时候，大事务如何做到快速提交 ==&gt; 先写重做日志，回滚重做日志</p>
<p>3.btree的增删改操作处理， 有点复杂</p>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2019 侯铭健.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2019-07-14 13:24:14</p>
      </span>
    </div>

    
    
  </body>
</html>