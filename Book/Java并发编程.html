<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>Java并发编程 - 心之所动，且就随缘而去吧</title>
    <meta name="keywords" content=""/>
    <meta name="description" content="侯铭健的个人wiki"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/wiki/">Home</a>&nbsp;&#187;&nbsp;<a href="/wiki/#Book">Book</a>&nbsp;&#187;&nbsp;Java并发编程
    <span class="updated">Page Updated&nbsp;
      2016-08-07 14:52:31
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">Java并发编程</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#java">Java并发编程</a><ul>
<li><a href="#_1">什么是线程安全</a></li>
<li><a href="#_2">原子变量类</a></li>
<li><a href="#_3">串行和并行</a></li>
<li><a href="#volatile">volatile</a></li>
<li><a href="#synchronized">synchronized</a><ul>
<li><a href="#_4">锁重入</a></li>
</ul>
</li>
<li><a href="#_5">后记</a></li>
</ul>
</li>
</ul>
</div>
<h1 id="java">Java并发编程</h1>
<h2 id="_1">什么是线程安全</h2>
<p>当多个线程并发访问一个类、方法或对象时，如果该类始终能正确执行，得到正确的结果，则该方法就是线程安全的。</p>
<h2 id="_2">原子变量类</h2>
<p>AtomicIneger，AtomicLong，等等</p>
<p>之前接触到这种原子变量类还是在Redis写入的时候。为什么会用到这个呢？</p>
<p>之前看公司同事在操作redis的时候，发现他们写值的时候都是用到了AtomInteger这个类，今天碰巧读到了这个类，一开始以为这样是为了防并发的，但是今天网上搜了一下，发现redis内部是单线程的，每次操作都具有原子性。那么为什么还要用AtomInteger这个类呢？</p>
<h2 id="_3">串行和并行</h2>
<p>并行不一定比串行快，因为线程有创建和上下文切换的开销，个人觉得创建比较耗时。</p>
<h2 id="volatile">volatile</h2>
<p>volatile，比 synchronized更轻量级的实现，它保证了并发时，共享变量的可见性，即，一个线程修改了变量，另一个线程能读到这个修改的值</p>
<p>共享变量：可以看到，线程一般先从主内存中把变量取出，然后复制一个变量副本到本地内存中。再进行操作，如果变量被声明了volatile，则每次这个值的修改，都会使本地内存的副本失效，线程需要从主内存中重新获取值。即声明了volatile的变量可以使值是内存中最新的值。</p>
<p><img alt="共享变量" src="http://ww4.sinaimg.cn/large/005H7Wvyjw1f9pdmcjay2j30cs0avgmy.jpg" /></p>
<h2 id="synchronized">synchronized</h2>
<p>synchronized在java6之前很多人都称呼其为“重量级锁”，但是随着java后面的持续优化，有些情况下它就没那么重了。</p>
<p>synchronized是对象锁，如果类中两个方法都是被synchronized修饰，当并发访问时，会互相等待。</p>
<h3 id="_4">锁重入</h3>
<p>同一个线程，如果已经获取到锁后，要继续获取锁时，可以直接执行，不需要再获取锁。</p>
<h2 id="_5">后记</h2>
<p>2016-12-11:之前把这本书丢一边就没看了，今天重新拿起来看了一下。看到某一张的翻译。。什么“发布”， “逸出”，然后快速地把后面的内容粗略看了一下。发现这本书的翻译真的很有问题。。。很多粗浅的概念都翻译得很奇怪。看半天才看懂。。</p>
<p>可能后面有兴趣地话，会再去看看国人写的这方面的书吧。</p>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2018 侯铭健.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2018-07-08 01:45:00</p>
      </span>
    </div>

    
    
  </body>
</html>