
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../favicon.ico">

    <title>hibernate模块介绍、缓存、分页 - 9avalon wiki</title>

    <!-- Bootstrap core CSS -->
    <link href="../static/css/bootstrap.min.css" rel="stylesheet">
    <link href="../static/css/jumbotron-narrow.css" rel="stylesheet">
    <link href="../static/css/style.css" rel="stylesheet">
</head>

<body>

<div class="container">
	<ol class="breadcrumb">	
		<li><a href="/">Home</a></li><li><a href="/#Java\java1">Java\java1</a></li><li class="active">hibernate模块介绍、缓存、分页</li>
    </ol>
	
    <div class="header clearfix">
        <nav>
            <ul class="nav nav-pills pull-right">
            </ul>
        </nav>
        <h3 class="text-muted">hibernate模块介绍、缓存、分页</h3>
    </div>

    <div class="row wiki-main">
		<hr>
		<h2 id="session">Session</h2>
<p>一个轻量级的非线程安全对象，这里的session并不是指的HttpSession，可以理解为JDBC的Session。
SessionFactory负责创建session，而SessionFactory是线程安全的，多个并发线程可以同时访问一个SessionFactory并从中获取Session实例。
而Session是线程不安全的，所以如果有多个线程同时对Session进行操作就会导致Session出错。因为创建的Session实例必须与线程相关。这里会用到ThreadLocal。</p>
<h2 id="sessionfactory">SessionFactory</h2>
<p>负责初始化hibernate，可以创建Session，是线程安全的，一般而言SessionFactory会在Hibernate启动时创建一次，因为，为了便于利用，SessionFacctory应该用一个单例模式来实现。</p>
<h2 id="transaction">Transaction</h2>
<p>负责相关的事务操作</p>
<h2 id="query">Query</h2>
<p>负责执行各种数据库查询，一般都Session的createQuery方法创建。</p>
<h2 id="configuration">Configuration</h2>
<p>用于读取hibernate配置文件，并生成SessionFactory对象</p>
<h2 id="hibernate">Hibernate使用介绍</h2>
<p>1、应用程序通过Configuration读取配置文件并生成SessionFactory
<code>SessionFactory sessionFactory = new Configuration().configure().buildSessionfactory();</code>
2、通过SessionFactory生成一个Session对象
<code>Session sesssion = sessionFactory.openSession();</code>
3、创建事务
<code>Transaction t = session.beginTransaction()</code>
4、session操作数据
然后可以用session对象里面的各种方法操作数据,也可以通过session生成一个Query对象执行查询操作。</p>
<h2 id="hibernate_1">如何提高Hibernate的性能？</h2>
<p>1、懒加载
2、缓存</p>
<h2 id="hibernate_2">什么是hibernate的二级缓存？</h2>
<p>一级缓存：由session管理，当使用Session查询数据时，首先会在该Session内部中查找该对象是否存在，如果有则直接返回。但是因为Session是线程不安全的，这意味着session中的缓存并不能被多个线程共享，因为一级缓存的提升效果不太明显。
二级缓存：二级缓存用来为hibernate配置一种全局的缓存，实现多个线程与事务共享数据。在使用了二级缓存后，当查询数据时，会首先在内部缓存中去查找，如果不存在，接着在二级缓存中查找，都不存在才会到数据库找。
二级缓存适用的场景：数据量小的，修改少的，不会被大量的应用共享的数据（多线程影响性能），不是很重要的数据。</p>
<h2 id="_1">如何实现分页</h2>
<p>Hibernate自带分页机制</p>
<div class="hlcode"><pre><span class="n">Query</span> <span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">&quot;from table&quot;</span><span class="err">&quot;</span><span class="o">);</span>
<span class="n">q</span><span class="o">.</span><span class="na">setFirstResult</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span> <span class="c1">//从第一百条记录开始</span>
<span class="n">q</span><span class="o">.</span><span class="na">setMaxResults</span><span class="o">(</span><span class="mi">50</span><span class="o">)</span> <span class="c1">//100条之后的50条</span>
<span class="n">List</span> <span class="n">l</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">list</span><span class="o">();</span>
</pre></div>


<p>当然也可以使用sql来进行分页，不过oracle不支持limit会比较麻烦，而mysql支持limit会比较简单。</p>
    </div>

    <footer class="footer">
        <p style="font-size: 12px">Copyright © 2016 . Powered by Simiki. Theme by 9avalon</p>
    </footer>

</div> <!-- /container -->

</body>
</html>