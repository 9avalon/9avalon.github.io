
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../static/favicon.ico">

    <title>hibernate - 9avalon wiki</title>

    <!-- Bootstrap core CSS -->
    <link href="../static/css/bootstrap.min.css" rel="stylesheet">
    <link href="../static/css/jumbotron-narrow.css" rel="stylesheet">
    <link href="../static/css/style.css" rel="stylesheet">
	<link href="../static/css/tango.css" rel="stylesheet">
</head>

<body>

<div class="container">
	<ol class="breadcrumb">	
		<li><a href="/">Home</a></li><li><a href="/#Java">Java</a></li><li class="active">hibernate</li>
    </ol>
	
    <div class="header clearfix">
        <nav>
            <ul class="nav nav-pills pull-right">
            </ul>
        </nav>
        <h3 class="text-muted">hibernate</h3>
    </div>

    <div class="row wiki-main">
		<div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#hibernate">hibernate组成</a></li>
<li><a href="#hibernate_1">Hibernate使用</a></li>
<li><a href="#_1">关于缓存</a><ul>
<li><a href="#hibernate_2">什么是hibernate的二级缓存？</a></li>
<li><a href="#_2">缓存的原理</a></li>
<li><a href="#_3">二级缓存的更新问题</a></li>
</ul>
</li>
<li><a href="#_4">实现分页</a></li>
</ul>
</div>
<h3 id="hibernate">hibernate组成</h3>
<p><strong>Session</strong></p>
<p>一个轻量级的非线程安全对象，这里的session并不是指的HttpSession，可以理解为JDBC的Session。
SessionFactory负责创建session，而SessionFactory是线程安全的，多个并发线程可以同时访问一个SessionFactory并从中获取Session实例。
而Session是线程不安全的，所以如果有多个线程同时对Session进行操作就会导致Session出错。因为创建的Session实例必须与线程相关。这里会用到ThreadLocal。
<strong>SessionFactory</strong></p>
<p>负责初始化hibernate，可以创建Session，是线程安全的，一般而言SessionFactory会在Hibernate启动时创建一次，因为，为了便于利用，SessionFacctory应该用一个单例模式来实现。
<strong>Transaction</strong></p>
<p>负责相关的事务操作
<strong>Query</strong></p>
<p>负责执行各种数据库查询，一般都Session的createQuery方法创建。</p>
<p><strong>Configuration</strong>
用于读取hibernate配置文件，并生成SessionFactory对象</p>
<h3 id="hibernate_1">Hibernate使用</h3>
<p>1、应用程序通过Configuration读取配置文件并生成SessionFactory
<code>SessionFactory sessionFactory = new Configuration().configure().buildSessionfactory();</code>
2、通过SessionFactory生成一个Session对象
<code>Session sesssion = sessionFactory.openSession();</code>
3、创建事务
<code>Transaction t = session.beginTransaction()</code>
4、session操作数据
然后可以用session对象里面的各种方法操作数据,也可以通过session生成一个Query对象执行查询操作。</p>
<p>下面是一个java使用的例子：</p>
<div class="hlcode"><pre><span class="n">Configuration</span> <span class="n">cfg</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="n">SessionFactory</span> <span class="n">sf</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="n">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

<span class="c1">//读取配置文件用</span>
<span class="n">cfg</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Configuration</span><span class="o">().</span><span class="na">configure</span><span class="o">();</span>
<span class="c1">//创建session，这个非常耗时，应该变成单例模式管理</span>
<span class="n">sf</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="na">buildSessionFactory</span><span class="o">();</span>

<span class="c1">//此处创建session</span>
<span class="c1">//需要注意的是这里的session不是web中的session，而是hibernate的session</span>
<span class="c1">//session用完后必须关闭</span>
<span class="k">try</span><span class="o">{</span>
    <span class="n">session</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="na">openSession</span><span class="o">();</span>
    <span class="n">session</span><span class="o">.</span><span class="na">beginTransaction</span><span class="o">();</span>
    <span class="n">session</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">bl</span><span class="o">);</span>
    <span class="n">session</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">().</span><span class="na">commit</span><span class="o">();</span>

<span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//回滚事务</span>
    <span class="n">session</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">().</span><span class="na">rollback</span><span class="o">();</span>
<span class="o">}</span><span class="k">finally</span><span class="o">{</span>
    <span class="c1">//关闭session</span>
    <span class="n">session</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="n">sf</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>


<h3 id="_1">关于缓存</h3>
<p>要提升hibernate的性能可以分别从懒加载和缓存入手，其中缓存又分为一级缓存和二级缓存</p>
<h4 id="hibernate_2">什么是hibernate的二级缓存？</h4>
<p>一级缓存：由session管理，当使用Session查询数据时，首先会在该Session内部中查找该对象是否存在，如果有则直接返回。但是因为Session是线程不安全的，这意味着session中的缓存并不能被多个线程共享，因为一级缓存的提升效果不太明显。
二级缓存：二级缓存用来为hibernate配置一种全局的缓存，实现多个线程与事务共享数据。在使用了二级缓存后，当查询数据时，会首先在内部缓存中去查找，如果不存在，接着在二级缓存中查找，都不存在才会到数据库找。
二级缓存适用的场景：数据量小的，修改少的，不会被大量的应用共享的数据（多线程影响性能），不是很重要的数据。</p>
<h4 id="_2">缓存的原理</h4>
<p>先到session中查找有没有数据，如果没有就去查数据库数据。</p>
<h4 id="_3">二级缓存的更新问题</h4>
<p>一般来说，二级缓存主要用于那些不常更新的表中。</p>
<h3 id="_4">实现分页</h3>
<p>Hibernate自带分页机制</p>
<div class="hlcode"><pre><span class="n">Query</span> <span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">&quot;from table&quot;</span><span class="err">&quot;</span><span class="o">);</span>
<span class="n">q</span><span class="o">.</span><span class="na">setFirstResult</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span> <span class="c1">//从第一百条记录开始</span>
<span class="n">q</span><span class="o">.</span><span class="na">setMaxResults</span><span class="o">(</span><span class="mi">50</span><span class="o">)</span> <span class="c1">//100条之后的50条</span>
<span class="n">List</span> <span class="n">l</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">list</span><span class="o">();</span>
</pre></div>


<p>当然也可以使用sql来进行分页，不过oracle不支持limit会比较麻烦，而mysql支持limit会比较简单。</p>
    </div>

    <footer class="footer">
        <p style="font-size: 12px">Copyright © 2016 . Powered by Simiki. Theme by 9avalon</p>
    </footer>

</div> <!-- /container -->

</body>
</html>