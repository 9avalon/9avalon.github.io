
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../static/favicon.ico">

    <title>hibernate - 9avalon wiki</title>

    <!-- Bootstrap core CSS -->
    <link href="../static/css/bootstrap.min.css" rel="stylesheet">
    <link href="../static/css/jumbotron-narrow.css" rel="stylesheet">
    <link href="../static/css/style.css" rel="stylesheet">
	<link href="../static/css/tango.css" rel="stylesheet">
</head>

<body>

<div class="container">
	<ol class="breadcrumb">	
		<li><a href="/">Home</a></li><li><a href="/#Java">Java</a></li><li class="active">hibernate</li>
    </ol>
	
    <div class="header clearfix">
        <nav>
            <ul class="nav nav-pills pull-right">
            </ul>
        </nav>
        <h3 class="text-muted">hibernate</h3>
    </div>

    <div class="row wiki-main">
		<div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#hibernate">hibernate组成</a></li>
<li><a href="#hibernate_1">Hibernate使用</a></li>
<li><a href="#_1">关于缓存</a><ul>
<li><a href="#hibernate_2">什么是hibernate的二级缓存？</a></li>
<li><a href="#_2">缓存的原理</a></li>
<li><a href="#_3">二级缓存的更新问题</a></li>
</ul>
</li>
<li><a href="#_4">实现分页</a></li>
<li><a href="#spirng">与Spirng的整合</a></li>
</ul>
</div>
<h3 id="hibernate">hibernate组成</h3>
<p><strong>Session</strong>
一个轻量级的非线程安全对象，这里的session并不是指的HttpSession，可以理解为JDBC的Session。
SessionFactory负责创建session，而SessionFactory是线程安全的，多个并发线程可以同时访问一个SessionFactory并从中获取Session实例。
而Session是线程不安全的，所以如果有多个线程同时对Session进行操作就会导致Session出错。因为创建的Session实例必须与线程相关。这里会用到ThreadLocal。
<strong>SessionFactory</strong>
负责初始化hibernate，可以创建Session，是线程安全的，一般而言SessionFactory会在Hibernate启动时创建一次，因为，为了便于利用，SessionFacctory应该用一个单例模式来实现。
<strong>Transaction</strong>
负责相关的事务操作
<strong>Query</strong>
负责执行各种数据库查询，一般都Session的createQuery方法创建。
<strong>Configuration</strong>
用于读取hibernate配置文件，并生成SessionFactory对象</p>
<h3 id="hibernate_1">Hibernate使用</h3>
<p>1、应用程序通过Configuration读取配置文件并生成SessionFactory
<code>SessionFactory sessionFactory = new Configuration().configure().buildSessionfactory();</code>
2、通过SessionFactory生成一个Session对象
<code>Session sesssion = sessionFactory.openSession();</code>
3、创建事务
<code>Transaction t = session.beginTransaction()</code>
4、session操作数据
然后可以用session对象里面的各种方法操作数据,也可以通过session生成一个Query对象执行查询操作。</p>
<p>下面是一个java使用的例子：</p>
<div class="hlcode"><pre><span class="n">Configuration</span> <span class="n">cfg</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="n">SessionFactory</span> <span class="n">sf</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="n">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

<span class="c1">//读取配置文件用</span>
<span class="n">cfg</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Configuration</span><span class="o">().</span><span class="na">configure</span><span class="o">();</span>
<span class="c1">//创建session，这个非常耗时，应该变成单例模式管理</span>
<span class="n">sf</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="na">buildSessionFactory</span><span class="o">();</span>

<span class="c1">//此处创建session</span>
<span class="c1">//需要注意的是这里的session不是web中的session，而是hibernate的session</span>
<span class="c1">//session用完后必须关闭</span>
<span class="k">try</span><span class="o">{</span>
    <span class="n">session</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="na">openSession</span><span class="o">();</span>
    <span class="n">session</span><span class="o">.</span><span class="na">beginTransaction</span><span class="o">();</span>
    <span class="n">session</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">bl</span><span class="o">);</span>
    <span class="n">session</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">().</span><span class="na">commit</span><span class="o">();</span>

<span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//回滚事务</span>
    <span class="n">session</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">().</span><span class="na">rollback</span><span class="o">();</span>
<span class="o">}</span><span class="k">finally</span><span class="o">{</span>
    <span class="c1">//关闭session</span>
    <span class="n">session</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="n">sf</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>


<h3 id="_1">关于缓存</h3>
<p>要提升hibernate的性能可以分别从懒加载和缓存入手，其中缓存又分为一级缓存和二级缓存</p>
<h4 id="hibernate_2">什么是hibernate的二级缓存？</h4>
<p>一级缓存：由session管理，当使用Session查询数据时，首先会在该Session内部中查找该对象是否存在，如果有则直接返回。但是因为Session是线程不安全的，这意味着session中的缓存并不能被多个线程共享，因为一级缓存的提升效果不太明显。
二级缓存：二级缓存用来为hibernate配置一种全局的缓存，实现多个线程与事务共享数据。在使用了二级缓存后，当查询数据时，会首先在内部缓存中去查找，如果不存在，接着在二级缓存中查找，都不存在才会到数据库找。
二级缓存适用的场景：数据量小的，修改少的，不会被大量的应用共享的数据（多线程影响性能），不是很重要的数据。</p>
<h4 id="_2">缓存的原理</h4>
<p>先到session中查找有没有数据，如果没有就去查数据库数据。</p>
<h4 id="_3">二级缓存的更新问题</h4>
<p>一般来说，二级缓存主要用于那些不常更新的表中。</p>
<h3 id="_4">实现分页</h3>
<p>Hibernate自带分页机制</p>
<div class="hlcode"><pre><span class="n">Query</span> <span class="n">q</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">&quot;from table&quot;</span><span class="err">&quot;</span><span class="o">);</span>
<span class="n">q</span><span class="o">.</span><span class="na">setFirstResult</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span> <span class="c1">//从第一百条记录开始</span>
<span class="n">q</span><span class="o">.</span><span class="na">setMaxResults</span><span class="o">(</span><span class="mi">50</span><span class="o">)</span> <span class="c1">//100条之后的50条</span>
<span class="n">List</span> <span class="n">l</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">list</span><span class="o">();</span>
</pre></div>


<p>当然也可以使用sql来进行分页，不过oracle不支持limit会比较麻烦，而mysql支持limit会比较简单。</p>
<h3 id="spirng">与Spirng的整合</h3>
<p>spring的配置文件中加入</p>
<div class="hlcode"><pre>    <span class="c">&lt;!-- 读取jdbc文件 --&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">&quot;org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;locations&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;list&gt;</span>
                <span class="nt">&lt;value&gt;</span>classpath:config/jdbc.properties<span class="nt">&lt;/value&gt;</span>
            <span class="nt">&lt;/list&gt;</span>
        <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&quot;dataSource&quot;</span> <span class="na">class=</span><span class="s">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span><span class="nt">&gt;</span>
        <span class="c">&lt;!-- 用户名 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;user&quot;</span> <span class="na">value=</span><span class="s">&quot;${jdbc.username}&quot;</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!-- 用户密码 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;password&quot;</span> <span class="na">value=</span><span class="s">&quot;${jdbc.password}&quot;</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;driverClass&quot;</span> <span class="na">value=</span><span class="s">&quot;${jdbc.driver}&quot;</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;jdbcUrl&quot;</span> <span class="na">value=</span><span class="s">&quot;${jdbc.url}&quot;</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--连接池中保留的最大连接数。默认值: 15 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;maxPoolSize&quot;</span> <span class="na">value=</span><span class="s">&quot;20&quot;</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!-- 连接池中保留的最小连接数，默认为：3 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;minPoolSize&quot;</span> <span class="na">value=</span><span class="s">&quot;2&quot;</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!-- 初始化连接池中的连接数，取值应在minPoolSize与maxPoolSize之间，默认为3 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;initialPoolSize&quot;</span> <span class="na">value=</span><span class="s">&quot;2&quot;</span> <span class="nt">/&gt;</span>

        <span class="c">&lt;!--最大空闲时间，60秒内未使用则连接被丢弃。若为0则永不丢弃。默认值: 0 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;maxIdleTime&quot;</span> <span class="na">value=</span><span class="s">&quot;60&quot;</span> <span class="nt">/&gt;</span>

        <span class="c">&lt;!-- 当连接池连接耗尽时，客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException，如设为0则无限期等待。单位毫秒。默认: </span>
<span class="c">            0 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;checkoutTimeout&quot;</span> <span class="na">value=</span><span class="s">&quot;3000&quot;</span> <span class="nt">/&gt;</span>

        <span class="c">&lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。默认值: 3 --&gt;</span>
        <span class="c">&lt;!-- &lt;property name=&quot;acquireIncrement&quot; value=&quot;2&quot;/&gt; --&gt;</span>

        <span class="c">&lt;!--定义在从数据库获取新连接失败后重复尝试的次数。默认值: 30 ；小于等于0表示无限次 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;acquireRetryAttempts&quot;</span> <span class="na">value=</span><span class="s">&quot;0&quot;</span> <span class="nt">/&gt;</span>

        <span class="c">&lt;!--重新尝试的时间间隔，默认为：1000毫秒 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;acquireRetryDelay&quot;</span> <span class="na">value=</span><span class="s">&quot;1000&quot;</span> <span class="nt">/&gt;</span>

        <span class="c">&lt;!--关闭连接时，是否提交未提交的事务，默认为false，即关闭连接，回滚未提交的事务 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;autoCommitOnClose&quot;</span> <span class="na">value=</span><span class="s">&quot;false&quot;</span> <span class="nt">/&gt;</span>

        <span class="c">&lt;!--如果为false，则获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常，但是数据源仍有效保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试获取连接失败后该数据源将申明已断开并永久关闭。默认: </span>
<span class="c">            false --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;breakAfterAcquireFailure&quot;</span> <span class="na">value=</span><span class="s">&quot;false&quot;</span> <span class="nt">/&gt;</span>

        <span class="c">&lt;!--每60秒检查所有连接池中的空闲连接。默认值: 0，不检查 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;idleConnectionTestPeriod&quot;</span> <span class="na">value=</span><span class="s">&quot;60&quot;</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--c3p0全局的PreparedStatements缓存的大小。如果maxStatements与maxStatementsPerConnection均为0，则缓存不生效，只要有一个不为0，则语句的缓存就能生效。如果默认值: </span>
<span class="c">            0 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;maxStatements&quot;</span> <span class="na">value=</span><span class="s">&quot;100&quot;</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。默认值: 0 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;maxStatementsPerConnection&quot;</span> <span class="na">value=</span><span class="s">&quot;10&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&quot;sessionFactory&quot;</span> <span class="na">class=</span><span class="s">&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;</span><span class="nt">&gt;</span>
        <span class="c">&lt;!-- 配置数据源 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;dataSource&quot;</span> <span class="na">ref=</span><span class="s">&quot;dataSource&quot;</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!-- 扫描包 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;packagesToScan&quot;</span> <span class="na">value=</span><span class="s">&quot;org.daxiang.resume.po&quot;</span><span class="nt">&gt;</span> <span class="nt">&lt;/property&gt;</span>
        <span class="c">&lt;!--hibernate参数配置 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;hibernateProperties&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;props&gt;</span>
                <span class="nt">&lt;prop</span> <span class="na">key=</span><span class="s">&quot;hibernate.dialect&quot;</span><span class="nt">&gt;</span> org.hibernate.dialect.MySQLDialect <span class="nt">&lt;/prop&gt;</span>
                <span class="nt">&lt;prop</span> <span class="na">key=</span><span class="s">&quot;hibernate.show_sql&quot;</span><span class="nt">&gt;</span>true<span class="nt">&lt;/prop&gt;</span>
                <span class="nt">&lt;prop</span> <span class="na">key=</span><span class="s">&quot;hibernate.current_session_context_class&quot;</span><span class="nt">&gt;</span>org.springframework.orm.hibernate4.SpringSessionContext<span class="nt">&lt;/prop&gt;</span>
                <span class="nt">&lt;prop</span> <span class="na">key=</span><span class="s">&quot;jdbc.use_scrollable_resultset&quot;</span><span class="nt">&gt;</span>false<span class="nt">&lt;/prop&gt;</span>
                <span class="c">&lt;!-- &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;none&lt;/prop&gt; </span>
<span class="c">                     &lt;prop key=&quot;hibernate.jdbc.fetch_size&quot;&gt;50&lt;/prop&gt; </span>
<span class="c">                     &lt;prop key=&quot;hibernate.jdbc.batch_size&quot;&gt;30&lt;/prop&gt; --&gt;</span>
            <span class="nt">&lt;/props&gt;</span>
        <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>
</pre></div>


<p>web.xml中加入</p>
<div class="hlcode"><pre>  <span class="c">&lt;!-- 配置Session --&gt;</span>
  <span class="nt">&lt;filter&gt;</span>
    <span class="nt">&lt;filter-name&gt;</span>openSession<span class="nt">&lt;/filter-name&gt;</span>
    <span class="nt">&lt;filter-class&gt;</span>org.springframework.orm.hibernate4.support.OpenSessionInViewFilter<span class="nt">&lt;/filter-class&gt;</span>
  <span class="nt">&lt;/filter&gt;</span>
  <span class="nt">&lt;filter-mapping&gt;</span>
    <span class="nt">&lt;filter-name&gt;</span>openSession<span class="nt">&lt;/filter-name&gt;</span>
    <span class="nt">&lt;url-pattern&gt;</span>/*<span class="nt">&lt;/url-pattern&gt;</span>
  <span class="nt">&lt;/filter-mapping&gt;</span>
</pre></div>
    </div>

    <footer class="footer">
        <p style="font-size: 12px">Copyright © 2016 . Powered by Simiki. Theme by 9avalon</p>
    </footer>

</div> <!-- /container -->

</body>
</html>