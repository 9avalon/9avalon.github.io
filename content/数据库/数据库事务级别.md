---
title: 事务隔离级别
date: 2016-6-24 21:41:34
---

[TOC]

#### 数据库的隔离级别
简单来说就是：读没提交的，读提交的，可以重复读，序列化

#### 主流数据库的事务隔离级别
Mysql ： 重复读
Oracle、SqlServer：  读提交

#### Read uncommitted(读未提交)
> 公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有2000元，singo空欢喜一场。

即读取了别人还没提交事务的数据。即脏读。

#### Read committed(读提交)
> singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为何......

即可重复读
两个并发事务AB，A先读取了数据，然后B在A之后读取了数据并比A更快地提交了数据，A再读数据，就会产生读取数据的变化。
场景举例：我现在看了一下支付宝余额，还剩2块钱，然后我想买瓶饮料。突然2块钱被别人划走了，我买饮料的时候再次读取余额就是0元，然后购买就失败了。

#### Repeatable read(重复读)
如上边的例子，当singo开启事务后读取了卡里金额数据，那他的老婆就不能对这条数据进行修改。
> 虽然Repeatable read避免了不可重复读，但还有可能出现幻读。
> singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额（select sum(amount) from transaction where month = 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction ... ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出现了幻觉，幻读就这样产生了。

#### 序列化（也可以成为串行事务，一个事务一个事务接着运行）
最高的事务隔离级别，为了事务性能很低，花销很大。（可避免幻读）




