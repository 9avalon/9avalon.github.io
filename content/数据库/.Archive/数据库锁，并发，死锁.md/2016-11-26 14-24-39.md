2---
title: 数据库锁，并发，死锁
date: 2016-8-3 14:53:45
---
### 行锁和表锁
首先介绍一下行锁和表锁

**表锁**顾明思议是把整张表给锁住，表锁并发度低，但管理锁的开销较小


**行锁**是把表的一条纪录锁住，并发度较高，管理锁的开销大。


锁定的单元越小，并发能力越高，管理锁的开销越大。



### 乐观锁和悲观锁：

乐观锁：事务把记录锁住，可以允许其他事务读取该记录，但是该记录不能被其他事务修改。

悲观锁：事务将记录锁住，不允许其他事务读取和修改该记录



### 死锁的产生例子

使用排它锁会有可能出现死锁的情况。

假如当前有两个线程A和B，数据库某张表中C记录，D记录

1、A发起请求，对C记录进行查询，并使用了排它锁，将此记录锁住。

2、B随后发起请求，对D纪录进行查询，同样把纪录锁住。

3、此时，A纪录要访问D纪录，但由于B把D纪录锁了，所以A会一直等待直到B把D纪录的锁释放。

4、在A等待的时候，B却要对C纪录进行访问，但是C纪录的锁在A上，因此B要等待直到A释放C纪录的锁。

5、两者互相等待，死锁产生了。



### 避免死锁

使用事务时，尽量缩短事务逻辑处理过程，及早提交和回滚事务。

设置死锁超时时间

合理安排表访问顺序



### 一些问题

Q:select for update是什么锁？

A:行锁



### 文章推荐

不错的文章

[mysql事务和锁InnoDB](http://www.cnblogs.com/zhaoyl/p/4121010.html)

[大数据量下高并发同步的讲解](http://www.cnblogs.com/xiohao/p/4385508.html)

