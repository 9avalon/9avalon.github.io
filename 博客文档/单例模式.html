
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../favicon.ico">

    <title>设计模式之单例模式 - 9avalon wiki</title>

    <!-- Bootstrap core CSS -->
    <link href="../static/css/bootstrap.min.css" rel="stylesheet">
    <link href="../static/css/jumbotron-narrow.css" rel="stylesheet">
    <link href="../static/css/style.css" rel="stylesheet">
</head>

<body>

<div class="container">
	<ol class="breadcrumb">	
		<li><a href="/">Home</a></li><li><a href="/#博客文档">博客文档</a></li><li class="active">设计模式之单例模式</li>
    </ol>
	
    <div class="header clearfix">
        <nav>
            <ul class="nav nav-pills pull-right">
            </ul>
        </nav>
        <h3 class="text-muted">设计模式之单例模式</h3>
    </div>

    <div class="row wiki-main">
		<hr>
		<p>单例模式是属于比较简单，容易理解的设计模式，我们在课堂上都应该能轻易理解如何使用单例模式。</p>
<h4 id="_1">什么是单例模式</h4>
<p>在系统运行时，有些类在系统中只需要存在一个实例即可。例如比较常见的是window的回收站，整个系统只需要维护一个回收站就可以了。单例模式的好处是节省了不必要的资源开销，只需要维护一份实例就可以了。</p>
<h4 id="_2">最常见的单例模式</h4>
<p>这种方式创建的单例模式是线程不安全的，当两个线程并发调用获取实例的方法时，可能会new两次实例。破坏了单例。</p>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Single</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">Single</span> <span class="n">single</span><span class="o">;</span>

    <span class="c1">//隐藏构造方法</span>
    <span class="kd">private</span> <span class="nf">Single</span><span class="o">(){}</span>

    <span class="kd">public</span> <span class="n">Single</span> <span class="nf">getInstance</span><span class="o">(){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">single</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">single</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Single</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">single</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<h4 id="_3">改进版，线程安全</h4>
<p>在获取实例的方法前加了同步关键字，确保了并发环境中只能有一个线程访问这个方法。但是加上了同步关键字之后性能会降低很多。</p>
<div class="hlcode"><pre><span class="kd">public</span> <span class="kd">synchronized</span> <span class="n">Single</span> <span class="nf">getInstance</span><span class="o">(){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">single</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
        <span class="n">single</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Single</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">single</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<h4 id="1">改进版+1，双重校验锁</h4>
<p>改进之后，只有single为空的时候才会进入同步方法里面新建实例。</p>
<div class="hlcode"><pre>    <span class="kd">public</span> <span class="n">Single</span> <span class="nf">getInstance</span><span class="o">(){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">single</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">Single</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">single</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="n">single</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Single</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">single</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>


<blockquote>
<p>这段代码看起来很完美，很可惜，它是有问题。主要在于single=new Single()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。
1、给 single 分配内存
2、调用 Single的构造函数来初始化成员变量
3、将single对象指向分配的内存空间（执行完这步 single 就为非 null 了）
但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 single 已经是非 null 了（但却没有初始化），所以线程二会直接返回 single，然后使用，然后顺理成章地报错。</p>
</blockquote>
<p>所以最终的解决方案是利用volatile来使得指令顺序不排序。</p>
<div class="hlcode"><pre><span class="kd">private</span> <span class="kd">volatile</span> <span class="kd">static</span> <span class="n">Single</span> <span class="n">single</span><span class="o">;</span>
</pre></div>
    </div>

    <footer class="footer">
        <p style="font-size: 12px">Copyright © 2016 . Powered by Simiki. Theme by 9avalon</p>
    </footer>

</div> <!-- /container -->

</body>
</html>