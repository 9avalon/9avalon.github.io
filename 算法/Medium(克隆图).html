<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>(Medium)克隆图 - Miguel's Wiki</title>
    <meta name="keywords" content=""/>
    <meta name="description" content="Miguel个人wiki"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="referrer" content="no-referrer" />
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/wiki/">Home</a>&nbsp;&#187;&nbsp;<a href="/wiki/#算法">算法</a>&nbsp;&#187;&nbsp;(Medium)克隆图
    <span class="updated">Page Updated&nbsp;
      2020-08-12 11:10:35
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">(Medium)克隆图</div>

  <div class="hlcode"><pre><span class="err">给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</span>

<span class="err">图中的每个节点都包含它的值</span> <span class="nx">val</span><span class="err">（</span><span class="nx">int</span><span class="err">）</span> <span class="err">和其邻居的列表（</span><span class="nb">list</span><span class="err">[</span><span class="nx">Node</span><span class="cp">]</span>）。

class Node {
    public int val;
    public List<span class="nt">&lt;Node&gt;</span> neighbors;
}
 

测试用例格式：

简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。

邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。

给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。

示例 1：

输入：adjList = <span class="cp">[</span><span class="err">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="cp">]</span>,<span class="cp">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="cp">]</span>,<span class="cp">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="cp">]</span>,<span class="cp">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="cp">]</span>]
输出：<span class="cp">[</span><span class="err">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="cp">]</span>,<span class="cp">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="cp">]</span>,<span class="cp">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="cp">]</span>,<span class="cp">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="cp">]</span>]
解释：
图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
示例 2：



输入：adjList = <span class="cp">[</span><span class="err">[</span><span class="cp">]</span>]
输出：<span class="cp">[</span><span class="err">[</span><span class="cp">]</span>]
解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。
示例 3：

输入：adjList = <span class="cp">[]</span>
输出：<span class="cp">[]</span>
解释：这个图是空的，它不含任何节点。
示例 4：



输入：adjList = <span class="cp">[</span><span class="err">[</span><span class="mi">2</span><span class="cp">]</span>,<span class="cp">[</span><span class="mi">1</span><span class="cp">]</span>]
输出：<span class="cp">[</span><span class="err">[</span><span class="mi">2</span><span class="cp">]</span>,<span class="cp">[</span><span class="mi">1</span><span class="cp">]</span>]
 

提示：

节点数不超过 100 。
每个节点值 Node.val 都是唯一的，1 <span class="err">&lt;</span>= Node.val <span class="err">&lt;</span>= 100。
无向图是一个简单图，这意味着图中没有重复的边，也没有自环。
由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。
图是连通图，你可以从给定节点访问到所有节点。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/clone-graph
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</pre></div>


<p>题解:</p>
<div class="hlcode"><pre><span class="cm">/*</span>
<span class="cm">// Definition for a Node.</span>
<span class="cm">class Node {</span>
<span class="cm">    public int val;</span>
<span class="cm">    public List&lt;Node&gt; neighbors;</span>

<span class="cm">    public Node() {</span>
<span class="cm">        val = 0;</span>
<span class="cm">        neighbors = new ArrayList&lt;Node&gt;();</span>
<span class="cm">    }</span>

<span class="cm">    public Node(int _val) {</span>
<span class="cm">        val = _val;</span>
<span class="cm">        neighbors = new ArrayList&lt;Node&gt;();</span>
<span class="cm">    }</span>

<span class="cm">    public Node(int _val, ArrayList&lt;Node&gt; _neighbors) {</span>
<span class="cm">        val = _val;</span>
<span class="cm">        neighbors = _neighbors;</span>
<span class="cm">    }</span>
<span class="cm">}</span>
<span class="cm">*/</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="n">Node</span> <span class="nf">cloneGraph</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;());</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">newNode</span><span class="o">);</span>

        <span class="n">List</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">neighbors</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">n</span> <span class="o">:</span> <span class="n">neighbors</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">newNode</span><span class="o">.</span><span class="na">neighbors</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cloneGraph</span><span class="o">(</span><span class="n">n</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></div>


<p>分析： 一开始想用层序遍历的方法处理，后面使用了递归，都没想到如何处理重复节点的问题，后面看了题解。</p>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 Miguel.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-08-13 23:43:57</p>
      </span>
    </div>

    
    
  </body>
</html>